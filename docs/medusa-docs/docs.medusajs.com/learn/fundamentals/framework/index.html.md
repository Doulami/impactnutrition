# Framework Overview

In this chapter, you'll learn about the Medusa Framework and how it facilitates building customizations in your Medusa application.

## What is the Medusa Framework?

All commerce application require some degree of customization. So, it's important to choose a platform that facilitates building those customizations.

When you build customizations with other ecommerce platforms, they require you to pull data through HTTP APIs, run custom logic that span across systems in a separate application, and manually ensure data consistency across systems. This adds significant overhead and slows down development as you spend time managing complex distributed systems.

The Medusa Framework eliminates this overhead by providing powerful low-level APIs and tools that let you build any type of customization directly within your Medusa project. You can build custom features, orchestrate operations and query data seamlessy across systems, extend core functionality, and automate tasks in your Medusa application.

With the Medusa Framework, you can focus your efforts on building meaningful business customizations and continuously delivering new features.

Using the Medusa Framework, you can build customizations like:

- [Product Reviews](https://docs.medusajs.com/resources/how-to-tutorials/tutorials/product-reviews)
- [Deep integration with an ERP system](https://docs.medusajs.com/resources/recipes/erp)
- [CMS integration with seamless content retrieval](https://docs.medusajs.com/resources/integrations/guides/sanity)
- [Custom item pricing in the cart](https://docs.medusajs.com/resources/examples/guides/custom-item-price)
- [Automated restock notifications](https://docs.medusajs.com/resources/recipes/commerce-automation/restock-notification)
- [Re-usable payment provider integrations](https://docs.medusajs.com/resources/references/payment/provider)

### Framework Concepts and Tools

- [Medusa Container](https://docs.medusajs.com/learn/fundamentals/medusa-container)
- [Modules](https://docs.medusajs.com/learn/fundamentals/modules)
- [Module Links](https://docs.medusajs.com/learn/fundamentals/module-links)
- [Query](https://docs.medusajs.com/learn/fundamentals/module-links/query)
- [Data Models](https://docs.medusajs.com/learn/fundamentals/data-models)
- [Workflows](https://docs.medusajs.com/learn/fundamentals/workflows)
- [API Routes](https://docs.medusajs.com/learn/fundamentals/api-routes)
- [Events and Subscribers](https://docs.medusajs.com/learn/fundamentals/events-and-subscribers)
- [Scheduled Jobs](https://docs.medusajs.com/learn/fundamentals/scheduled-jobs)
- [Plugins](https://docs.medusajs.com/learn/fundamentals/plugins)

***

## Build Custom Features

The Medusa Framework allows you to build custom features tailored to your business needs.

To create a custom feature, you can create a [module](https://docs.medusajs.com/learn/fundamentals/modules) that contains your feature's data models and the logic to manage them. A module is integrated into your Medusa application without side effects.

### Data Model

```ts highlights={modelHighlights}
import { model } from "@medusajs/framework/utils"

export const Post = model.define("post", {
  id: model.id().primaryKey(),
  title: model.text(),
})
```

### Service

```ts highlights={serviceHighlights}
import { MedusaService } from "@medusajs/framework/utils"
import { Post } from "./post"

export class BlogModuleService extends MedusaService({
  Post,
}){
  // CRUD methods generated by MedusaService
}
```

### Module Definition

```ts
import { Module } from "@medusajs/framework/utils"
import { BlogModuleService } from "./service"

export const BLOG_MODULE = "blog"

export default Module(BLOG_MODULE, {
  service: BlogModuleService,
})
```

Then, you can build commerce features and flows in [workflows](https://docs.medusajs.com/learn/fundamentals/workflows) that use your module. By using workflows, you benefit from features like [rollback mechanism](https://docs.medusajs.com/learn/fundamentals/workflows/compensation-function) and [retry configuration](https://docs.medusajs.com/learn/fundamentals/workflows/retry-failed-steps).

### Step

```ts highlights={stepHighlights}
import { createStep, StepResponse } from "@medusajs/framework/workflows-sdk"
import { BlogModuleService, BLOG_MODULE } from "../../modules/blog"

type Input = {
  title: string
}

const createPostStep = createStep(
  "create-post", 
  async (input: Input, { container }) => {
    const blogModuleService: BlogModuleService = container.resolve(
      BLOG_MODULE
    )

    const post = await blogModuleService.createPosts(input.title)
    
    return new StepResponse(post, post.id)
  },
  async (postId, { container }) => {
    if (!postId) {
      return
    }

    const blogModuleService: BlogModuleService = container.resolve(
      BLOG_MODULE
    )

    await blogModuleService.deletePosts(postId)
  }
)
```

### Workflow

```ts
import { createWorkflow, WorkflowResponse } from "@medusajs/framework/workflows-sdk"
import { createPostStep } from "./steps"

type Input = {
  title: string
}

export const createPostWorkflow = createWorkflow(
  "create-post",
  (input: Input) => {
    const post = createPostStep(input)

    return new WorkflowResponse(post)
  }
)
```

Finally, you can expose your custom feature with [API routes](https://docs.medusajs.com/learn/fundamentals/api-routes) that are built on top of your module and workflows.

```ts title="API Route Example"
import type {
  MedusaRequest,
  MedusaResponse,
} from "@medusajs/framework/http"
import { createPostWorkflow } from "../../../workflows/create-post"

type PostRequestBody = {
  title: string
}

export const POST = async (
  req: MedusaRequest<PostRequestBody>,
  res: MedusaResponse
) => {
  const { result } = await createPostWorkflow(req.scope)
    .run({
      input: result.validatedBody,
    })

  return res.json(result)
}
```

### Examples

The following tutorials are step-by-step guides that show you how to build custom features using the Medusa Framework.

- [Product Reviews](https://docs.medusajs.com/resources/how-to-tutorials/tutorials/product-reviews): Build a product reviews feature in your Medusa application.
- [Wishlist](https://docs.medusajs.com/resources/plugins/guides/wishlist): Build a wishlist feature in your Medusa application.

### Start Learning

To learn more about the different concepts useful for building custom features, check out the following chapters:

- [Modules](https://docs.medusajs.com/learn/fundamentals/modules)
- [Workflows](https://docs.medusajs.com/learn/fundamentals/workflows)
- [API Routes](https://docs.medusajs.com/learn/fundamentals/api-routes)

***

## Extend Existing Features

The Medusa Framework is flexible and extensible, allowing you to extend and build on top of existing models and features.

To associate new properties and relations with an existing model, you can create a [module](https://docs.medusajs.com/learn/fundamentals/modules) with data models that define these additions. Then, you can define a [module link](https://docs.medusajs.com/learn/fundamentals/module-links) that associates two data models from separate modules.

### Module Link

```ts highlights={defineLinkHighlights}
import BrandModule from "../modules/brand"
import ProductModule from "@medusajs/medusa/product"
import { defineLink } from "@medusajs/framework/utils"

export default defineLink(
  {
    linkable: ProductModule.linkable.product,
    isList: true,
  },
  BrandModule.linkable.brand
)
```

### Data Model

```ts
import { model } from "@medusajs/framework/utils"

export const Brand = model.define("brand", {
  id: model.id().primaryKey(),
  name: model.text(),
})
```

### Service

```ts
import { MedusaService } from "@medusajs/framework/utils"
import { Brand } from "./models/brand"

class BrandModuleService extends MedusaService({
  Brand,
}) {

}

export default BrandModuleService
```

### Module Definition

```ts
import { Module } from "@medusajs/framework/utils"
import BrandModuleService from "./service"

export const BRAND_MODULE = "brand"

export default Module(BRAND_MODULE, {
  service: BrandModuleService,
})
```

Then, you can [hook into existing workflows](https://docs.medusajs.com/learn/fundamentals/workflows/workflow-hooks) to perform custom actions as part of existing features and flows. For example, you can create a brand when a product is created.

```ts title="Workflow Hook Example" highlights={hookHighlights}
import { createProductsWorkflow } from "@medusajs/medusa/core-flows"
import { StepResponse } from "@medusajs/framework/workflows-sdk"
import { Modules } from "@medusajs/framework/utils"
import { LinkDefinition } from "@medusajs/framework/types"
import { BRAND_MODULE } from "../../modules/brand"
import BrandModuleService from "../../modules/brand/service"

createProductsWorkflow.hooks.productsCreated(
  (async ({ products, additional_data }, { container }) => {
    if (!additional_data?.brand_id) {
      return new StepResponse([], [])
    }

    const brandModuleService: BrandModuleService = container.resolve(
      BRAND_MODULE
    )
    
    const brand = await brandModuleService.createBrands({
      name: additional_data.brand_name,
    })
  })
)
```

You can also build custom workflows using your custom module and Medusa's modules, and use [existing workflows and steps](https://docs.medusajs.com/resources/medusa-workflows-reference) within your custom workflows.

### Examples

The following tutorials are step-by-step guides that show you how to extend existing features using the Medusa Framework.

- [Custom Item Pricing](https://docs.medusajs.com/resources/examples/guides/custom-item-price): Add products with custom items to the cart.
- [Loyalty Points System](https://docs.medusajs.com/resources/how-to-tutorials/tutorials/loyalty-points): Reward and allow customers to redeem loyalty points.

### Start Learning

To learn more about the different concepts useful for extending features, check out the following chapters:

- [Modules](https://docs.medusajs.com/learn/fundamentals/modules)
- [Module Links](https://docs.medusajs.com/learn/fundamentals/module-links)
- [Workflow Hooks](https://docs.medusajs.com/learn/fundamentals/workflows/workflow-hooks)

***

## Integrate Third-Party Services

The Medusa Framework provides the tools and infrastructure to build a middleware solution for your commerce ecosystem. You can integrate third-party services, perform operations across systems, and query data from multiple sources.

### Orchestrate Operations Across Systems

The Medusa Framework solves one of the biggest hurdles for ecommerce platforms: orchestrating operations across systems. Medusa has a built-in durable execution engine to help complete tasks that span multiple systems.

You can integrate a third-party service in a [module](https://docs.medusajs.com/learn/fundamentals/modules). This module provides an interface to perform operations with the third-party service.

### Service

```ts highlights={erpServiceHighlights}
type Options = {
  apiKey: string
}

export default class ErpModuleService {
  private options: Options
  private client

  constructor({}, options: Options) {
    this.options = options
    // TODO initialize client that connects to ERP
  }

  async getProducts() {
    // assuming client has a method to fetch products
    return this.client.getProducts()
  }

  // TODO add more methods
}
```

### Module Definition

```ts
import { Module } from "@medusajs/framework/utils"
import ErpModuleService from "./service"

export const ERP_MODULE = "erp"

export default Module(ERP_MODULE, {
  service: ErpModuleService,
})
```

Then, you can build [workflows](https://docs.medusajs.com/learn/fundamentals/workflows) that perform operations across systems. In the workflow, you can use your module to interact with the integrated third-party service.

For example, you can create a workflow that syncs products from your ERP system to your Medusa application.

### Workflow

```ts highlights={erpWorkflowHighlights}
import { 
  createWorkflow, 
  WorkflowResponse,
  transform,
} from "@medusajs/framework/workflows-sdk"
import { createProductsWorkflow } from "@medusajs/medusa/core-flows"

export const syncFromErpWorkflow = createWorkflow(
  "sync-from-erp",
  () => {
    const erpProducts = getProductsFromErpStep()

    const productsToCreate = transform({
      erpProducts,
    }, (data) => {
      // TODO prepare ERP products to be created in Medusa
      return data.erpProducts.map((erpProduct) => {
        return {
          title: erpProduct.title,
          external_id: erpProduct.id,
          variants: erpProduct.variants.map((variant) => ({
            title: variant.title,
            metadata: {
              external_id: variant.id,
            },
          })),
          // other data...
        }
      })
    })

    createProductsWorkflow.runAsStep({
      input: {
        products: productsToCreate,
      },
    })

    return new WorkflowResponse({
      erpProducts,
    })
  }
)
```

### Step

```ts
import { createStep, StepResponse } from "@medusajs/framework/workflows-sdk"
import { ERP_MODULE } from "../../modules/erp"
import { ErpModuleService } from "../../modules/erp/service"

const getProductsFromErpStep = createStep(
  "get-products-from-erp",
  async (_, { container }) => {
    const erpModuleService: ErpModuleService = container.resolve(
      ERP_MODULE
    )

    const products = await erpModuleService.getProducts()

    return new StepResponse(products)
  }
)
```

By using a workflow to manage operations across systems, you benefit from features like [rollback mechanism](https://docs.medusajs.com/learn/fundamentals/workflows/compensation-function), [background long-running execution](https://docs.medusajs.com/learn/fundamentals/workflows/long-running-workflow), [retry configuration](https://docs.medusajs.com/learn/fundamentals/workflows/retry-failed-steps), and more. This is essential for building a middleware solution that performs operations across systems, as you don't have to worry about data inconsistencies or failures.

You can then execute this workflow at a specific interval using [scheduled jobs](https://docs.medusajs.com/learn/fundamentals/scheduled-jobs) or when an event occurs using [events and subscribers](https://docs.medusajs.com/learn/fundamentals/events-and-subscribers). You can also expose its features to client applications using an [API route](https://docs.medusajs.com/learn/fundamentals/api-routes).

### Scheduled Job

```ts highlights={syncProductsJobHighlights}
import {
  MedusaContainer,
} from "@medusajs/framework/types"
import { syncFromErpWorkflow } from "../workflows/sync-from-erp"

export default async function syncProductsJob(container: MedusaContainer) {
  await syncFromErpWorkflow(container).run({})
}

export const config = {
  name: "daily-product-sync",
  schedule: "0 0 * * *", // Every day at midnight
}
```

### Event Subscriber

```ts highlights={productsCreatedHandlerHighlights}
import { SubscriberArgs, type SubscriberConfig } from "@medusajs/framework"
import { sendOrderConfirmationWorkflow } from "../workflows/send-order-confirmation"

export default async function productsCreatedHandler({
  event: { data },
  container,
}: SubscriberArgs<{ id: string }[]>) {
  await syncFromErpWorkflow(container).run({})
}

export const config: SubscriberConfig = {
  event: `product.created`,
}
```

### API Route

```ts highlights={apiRouteHighlights}
import type {
  MedusaRequest,
  MedusaResponse,
} from "@medusajs/framework/http"
import { syncFromErpWorkflow } from "../../../workflows/sync-from-erp"

export const POST = async (
  req: MedusaRequest,
  res: MedusaResponse
) => {
  const { result } = await syncFromErpWorkflow(req.scope).run({})

  return res.status(200).json(result)
}
```

#### Examples

The following tutorials are step-by-step guides that show you how to orchestrate operations across third-party services using the Medusa Framework.

- [Migrate Data from Magento](https://docs.medusajs.com/resources/integrations/guides/magento): Migrate data from Magento to your Medusa application.
- [Integrate Third-Party Services](https://docs.medusajs.com/resources/integrations): Integrate CMS, Fulfillment, Payment, and other third-party services.

#### Start Learning

To learn more about the different concepts useful for integrating third-party services, check out the following chapters:

- [Modules](https://docs.medusajs.com/learn/fundamentals/modules)
- [Workflows](https://docs.medusajs.com/learn/fundamentals/workflows)
- [API Routes](https://docs.medusajs.com/learn/fundamentals/api-routes)
- [Events and Subscribers](https://docs.medusajs.com/learn/fundamentals/events-and-subscribers)
- [Scheduled Jobs](https://docs.medusajs.com/learn/fundamentals/scheduled-jobs)

### Query Data Across Systems

Another essential feature for integrating third-party services is querying data across those systems efficiently.

The Framework allows you to build links not only between Medusa data models, but also virtual data models using [read-only module links](https://docs.medusajs.com/learn/fundamentals/module-links/read-only). You can build a [module](https://docs.medusajs.com/learn/fundamentals/modules) that provides the logic to query data from a third-party service, then create a read-only link between an existing data model and a virtual one from the third-party service.

### Read-Only Link

```ts highlights={readOnlyLinkHighlights}
import BrandModule from "../modules/brand"
import ProductModule from "@medusajs/medusa/product"
import { defineLink } from "@medusajs/framework/utils"

export default defineLink(
  {
    linkable: ProductModule.linkable.product,
    field: "id",
  },
  {
    ...BrandModule.linkable.brand.id,
    primaryKey: "product_id",
  },
  {
    readOnly: true,
  }
)
```

### Module Service

```ts highlights={brandModuleService}
type BrandModuleOptions = {
  apiKey: string
}

export default class BrandModuleService {
  private client

  constructor({}, options: BrandModuleOptions) {
    this.client = new Client(options)
  }

  async list(
    filter: {
      id: string | string[]
    }
  ) {
    return this.client.getBrands(filter)
    /**
     - Example of returned data:
     - 
     - [
     -   {
     -     "id": "brand_123",
     -     "name": "Brand 123",
     -     "product_id": "prod_321"
     -   },
     -   {
     -     "id": "post_456",
     -     "name": "Brand 456",
     -     "product_id": "prod_654"
     -   }
     - ]
    */
  }
}
```

### Module Definition

```ts
import { Module } from "@medusajs/framework/utils"
import BrandModuleService from "./service"

export const BRAND_MODULE = "brand"

export default Module(BRAND_MODULE, {
  service: BrandModuleService,
})
```

Then, you can use [Query](https://docs.medusajs.com/learn/fundamentals/module-links/query) to retrieve a product and its brand from the third-party service in a single query.

```ts title="Query Example" highlights={queryHighlights}
const { result } = await query.graph({
  entity: "product",
  fields: ["id", "brand.*"],
  filters: {
    id: "prod_123",
  },
})

// result = [{
//   id: "prod_123",
//   brand: {
//     id: "brand_123",
//     name: "Brand 123",
//     product_id: "prod_123"
//   }
//   ...
// }]
```

Query simplifies the process of retrieving data across systems, as you can retrieve data from multiple sources in a single query.

#### Examples

The following tutorials are step-by-step guides that show you how to query data across systems using the Medusa Framework.

- [Integrate Sanity CMS](https://docs.medusajs.com/resources/integrations/guides/sanity): Query data from third-party services using read-only links.

#### Start Learning

To learn more about the different concepts useful for querying data across systems, check out the following chapters:

- [Modules](https://docs.medusajs.com/learn/fundamentals/modules)
- [Read-Only Links](https://docs.medusajs.com/learn/fundamentals/module-links/read-only)
- [Query](https://docs.medusajs.com/learn/fundamentals/module-links/query)

***

## Automate Tasks

The Medusa Framework provides the tools to automate tasks in your Medusa application. Automation is useful when you want to perform a task periodically, such as syncing data, or when an event occurs, such as sending a confirmation email when an order is placed.

To build the task to be automated, you first create a [workflow](https://docs.medusajs.com/learn/fundamentals/workflows) that contains the task's logic, such as syncing data or sending an email.

### Step

```ts
import { Modules } from "@medusajs/framework/utils"
import { createStep, StepResponse } from "@medusajs/framework/workflows-sdk"
import { CreateNotificationDTO } from "@medusajs/framework/types"

export const sendNotificationStep = createStep(
  "send-notification",
  async (data: CreateNotificationDTO[], { container }) => {
    const notificationModuleService = container.resolve(
      Modules.NOTIFICATION
    )
    const notification = await notificationModuleService.createNotifications(
      data
    )
    return new StepResponse(notification)
  }
)
```

### Workflow

```ts
import { 
  createWorkflow, 
  WorkflowResponse,
} from "@medusajs/framework/workflows-sdk"
import { useQueryGraphStep } from "@medusajs/medusa/core-flows"
import { sendNotificationStep } from "./steps/send-notification"

type WorkflowInput = {
  id: string
}

export const sendOrderConfirmationWorkflow = createWorkflow(
  "send-order-confirmation",
  ({ id }: WorkflowInput) => {
    const { data: orders } = useQueryGraphStep({
      entity: "order",
      fields: [
        "id",
        "email",
        "currency_code",
        "total",
        "items.*",
      ],
      filters: {
        id,
      },
    })
    
    const notification = sendNotificationStep([{
      to: orders[0].email,
      channel: "email",
      template: "order-placed",
      data: {
        order: orders[0],
      },
    }])

    return new WorkflowResponse(notification)
  }
)
```

Then, you can execute this workflow when an event occurs using a [subscriber](https://docs.medusajs.com/learn/fundamentals/events-and-subscribers), or at a specific interval using a [scheduled job](https://docs.medusajs.com/learn/fundamentals/scheduled-jobs).

### Event Subscriber

```ts highlights={orderPlacedHandlerHighlights}
import type {
  SubscriberArgs,
  SubscriberConfig,
} from "@medusajs/framework"
import { sendOrderConfirmationWorkflow } from "../workflows/send-order-confirmation"

export default async function orderPlacedHandler({
  event: { data },
  container,
}: SubscriberArgs<{ id: string }>) {
  await sendOrderConfirmationWorkflow(container)
    .run({
      input: {
        id: data.id,
      },
    })
}

export const config: SubscriberConfig = {
  event: "order.placed",
}
```

### Scheduled Job

```ts highlights={orderConfirmationJobHighlights}
import type {
  MedusaContainer,
} from "@medusajs/framework/types"
import { sendOrderConfirmationWorkflow } from "../workflows/send-order-confirmation"

export default async function orderConfirmationJob(
  container: MedusaContainer
) {
  await sendOrderConfirmationWorkflow(container).run({
    input: {
      id: "order_123",
    },
  })
}
export const config = {
  name: "order-confirmation-job",
  schedule: "0 0 * * *", // Every day at midnight
}
```

### Examples

The following guides are step-by-step guides that show you how to automate tasks using the Medusa Framework.

- [Restock Notifications](https://docs.medusajs.com/resources/recipes/commerce-automation/restock-notification): Send restock notifications to customers when a product is back in stock.
- [Sync Data from and to ERP](https://docs.medusajs.com/resources/recipes/erp#sync-products-from-erp): Sync data between your Medusa application and an ERP system.

### Start Learning

To learn more about the different concepts useful for automating tasks, check out the following chapters:

- [Workflows](https://docs.medusajs.com/learn/fundamentals/workflows)
- [Events and Subscribers](https://docs.medusajs.com/learn/fundamentals/events-and-subscribers)
- [Scheduled Jobs](https://docs.medusajs.com/learn/fundamentals/scheduled-jobs)

***

## Re-Use Customizations Across Applications

If you have custom features that you want to re-use across multiple Medusa applications, or you want to publish your customizations for the community to use, you can build a [plugin](https://docs.medusajs.com/learn/fundamentals/plugins).

A plugin encapsulates your customizations in a single package. The customizations include [modules](https://docs.medusajs.com/learn/fundamentals/modules), [workflows](https://docs.medusajs.com/learn/fundamentals/workflows), [API routes](https://docs.medusajs.com/learn/fundamentals/api-routes), and more.

![Diagram showcasing a wishlist plugin installed in a Medusa application](https://res.cloudinary.com/dza7lstvk/image/upload/v1737540762/Medusa%20Book/plugin-diagram_oepiis.jpg)

You can then publish that plugin to NPM and install it in any Medusa application. This allows you to re-use your customizations efficiently across multiple projects, or share them with the community.

### Examples

The following tutorials are step-by-step guides that show you how to build plugins using the Medusa Framework.

- [Wishlist Plugin](https://docs.medusajs.com/resources/plugins/guides/wishlist): Build a wishlist plugin for your Medusa application.
- [Migrate Data from Magento Plugin](https://docs.medusajs.com/resources/integrations/guides/magento): Build a plugin that migrates data from Magento to your Medusa application.

### Start Learning

To learn more about the different concepts useful for building plugins, check out the following chapters:

- [Plugins](https://docs.medusajs.com/learn/fundamentals/plugins)
